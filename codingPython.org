#+TITLE: Coding Python

Does a literate-ish emacs document make a good place to learn python and develop the re-usable pieces I want for parsing lectionary data? Let's see.

* Reference
- [[https://linuxhint.com/configuring_emacs_python/][Configure like so]]
- [[https://orgmode.org/worg/org-contrib/babel/intro.html][Introduction to Babel]]
- Use C-c ' within the code block to edit
- Use C-c C-p within the editor to run it
- [[https://docs.python.org/3.9/][Python Doc's]]
- [[https://linuxhint.com/python_scripts_beginners_guide/][Python examples]]
- In interactive python, =dir(cmd)= is a great boon!
** Use python3
#+BEGIN_SRC bash
python3 --version
#+END_SRC

#+RESULTS:
: Python 3.9.1

#+BEGIN_SRC python :results output
  print ("Hello world!")
#+END_SRC

#+RESULTS:
: Hello world!

#+BEGIN_SRC python :results output
  import sys
  print (sys.version)
#+END_SRC

#+RESULTS:
: 2.7.16 (default, Nov 23 2020, 08:01:20)
: [GCC Apple LLVM 12.0.0 (clang-1200.0.30.4) [+internal-os, ptrauth-isa=sign+stri

#+BEGIN_SRC python :python python3 :results output
  import sys
  print (sys.version)
#+END_SRC

#+RESULTS:
: 3.9.1 (default, Jan  8 2021, 17:17:43)
: [Clang 12.0.0 (clang-1200.0.32.28)]
** Take a filename as input -- doesn't seem to work in babel?
#+BEGIN_SRC python :python python3 :results output :cmdline "a, b, c, 42"
import sys
if __name__ == "__main__":
    print(f"Arguments count: {len(sys.argv)}")
    for i, arg in enumerate(sys.argv):
        print(f"Argument {i:>6}: {arg}")
#+END_SRC

#+RESULTS:
: Arguments count: 1
: Argument      0:

** Traverse a text file
#+BEGIN_SRC python :python python3 :results output
  with open("collects.csv", "r") as f:
      for line in f:
          if (line[1:7]=="advent"):
              print (line[1:8])
#+END_SRC

#+RESULTS:
: advent1
: advent2
: advent3
: advent4

** Use the csv library
#+BEGIN_SRC python :python python3 :results output
  import csv
  with open("collects.csv", "r") as f:
      reader = csv.reader(f)
      for row in reader:
          if len(row[0])>0:
              print(row[0])
#+END_SRC

#+RESULTS:
#+begin_example
Code
advent1
advent2
advent3
advent4
nativity1
nativity2
nativity3
christmas1
holyname
christmas2
epiphany
epiphany1
epiphany2
epiphany3
epiphany4
presentation
epiphany5
epiphany6
epiphany7
epiphany8
epiphanylast
ashwednesday
lent1
lent2
lent3
lent4
lent5
annunciation
palmsunday
holymonday
holytuesday
holywednesday
maundythursday
goodfriday
holysaturday
vigil
easter
easterevening
eastermonday
eastertuesday
easterwednesday
easterthursday
easterfriday
eastersaturday
easter2
easter3
easter4
easter5
easter6
ascension
ascension-grant
easter7
pentecost-ogod
pentecost
trinity
visitation
proper1
proper2
proper3
proper4
proper5
proper6
proper7
proper8
proper9
proper10
proper11
proper12
proper13
proper14
proper15
proper16
proper17
proper18
proper19
holycross
proper20
proper21
proper22
proper23
thanksgivingcanadian
proper24
proper25
proper26
allsaints
proper27
proper28
proper29
thanksgivingusa
#+end_example

** Books of the Bible
Genesis
Exodus
Leviticus
Numbers
Deuteronomy
Joshua
Judges
Ruth
1 Samuel
2 Samuel
1 Kings
2 Kings
1 Chronicles
2 Chronicles
Ezra
Esther
Job
Psalms
Proverbs
Ecclesiastes
Song of Solomon
Isaiah
Jeremiah
Lamentations
Ezekiel
Daniel
Hosea
Joel
Amos
Obadiah
Jonah
Micah
Nahum
Habakkuk
Zephaniah
Haggai
Zechariah
Malachi
Tobit
Judith
Additions to Esther
Wisdom of Solomon
Sirach (Ecclesiasticus)
Baruch
1 Esdras
2 Esdras
Letter of Jeremiah
Prayer of Azariah and the Song of the Three Jews
Susanna
Bel and the Dragon
1 Maccabees
2 Maccabees
3 Maccabees
4 Maccabees
Prayer of Manasseh
Matthew
Mark
Luke
John
Acts of the Apostles
Romans
1 Corinthians
2 Corinthians
Galatians
Ephesians
Philippians
Colossians
1 Thessalonians
2 Thessalonians
1 Timothy
2 Timothy
Titus
Philemon
Hebrews
James
1 Peter
2 Peter
1 John
2 John
3 John
Jude
Revelation

* Output to files
** Dump collects into directory =collects=
#+BEGIN_SRC python :python python3 :results output
  import csv, os
  targetdir = "output/collects"
  os.makedirs(targetdir, exist_ok=True)
  count=0
  with open("collects.csv", "r") as f:
      reader = csv.reader(f)
      for row in reader:
          if row[0] == "Code": continue # Skip header row
          if len(row[0])<3: continue   # Skip uncoded or badly coded rows
          count+=1
          with open (targetdir + "/" + row[0], "w") as t:
            t.write(row[1])
  print ("Wrote " + str(count) + " records")
#+END_SRC

#+RESULTS:
: Wrote 118 records

** Dump multiple columns into directory =proper=
Each column gets its own sub-directory. Each entry is named with the week-code. e.g., =proper/collect/epiphany3=

#+BEGIN_SRC python :python python3 :results output
  import csv, os
  targetdir = "proper/"
  codeColumn = 1
  fields = {
      "collect": 2,
      "preface": 3,
      "title": 4
  }

  for dir in fields.keys():
    os.makedirs(targetdir + dir, exist_ok=True)

  count=0
  with open("bcplectionary.csv", "r") as f:
      reader = csv.reader(f)
      next(reader) # skip header line
      for row in reader:
          if row[0] == "999": continue # Skip unused rows
          code = row[1]
          if len(code)<3: continue   # Skip uncoded or badly coded rows
          count+=1
          for dir, column in fields.items():
              with open (targetdir + dir + "/" + code, "w") as t:
                  t.write(row[column])
  print ("Wrote " + str(count) + " records for each of " + str(len(fields)) + " fields.")
#+END_SRC

#+RESULTS:
: Wrote 115 records for each of 3 fields.
** Produce books of Bible lookup in =readings/intro=
Issue:
  - Philippians and Philemon require five characters to distinguish
  - Job 1 and Job 2 should use the same entry
 This sounds like a job for a regular expression!
 I like =^..[a-z]{1,3}= but the online testers don't catch the leading numerals. Maybe the fault of the javascript implementation?
Each file is named with the first five non-space characters, in lower case.

#+BEGIN_SRC python :python python3 :results output
  import csv, os
  targetdir = "readings/intro/"
  codeColumn = 1
  introColumn = 2

  os.makedirs(targetdir, exist_ok=True)

  count=0
  with open("booksofbible.csv", "r") as f:
      reader = csv.reader(f)
      next(reader) # skip header line
      for row in reader:
          if row[0] == "": continue # Skip unused rows
          code = row[1].lower().replace(" ","")[0:5]
          count+=1
          with open (targetdir + "/" + code, "w") as t:
              t.write(row[introColumn])
  print ("Wrote " + str(count) + " records.")
#+END_SRC

#+RESULTS:
: Wrote 82 records.

** Produce Psalms in =readings/pss/plaintext=
Format:
  - Blank line between Psalms/parts
  - # Psalm number (filename)
  - ## Part of Psalm or letter for Ps 119 (bold)
  - ### Latin title (italic)
  - Add "Part" to filename for those that contain the keyword
  - Psalm119: add a \n for each new letter heading

#+BEGIN_SRC python :python python3 :results output
  import os
  targetdir = "readings/pss/plaintext/"
  os.makedirs(targetdir, exist_ok=True)

  countLines = 0
  countPsalms = 0
  previousLine = ""
  with open("psalter.txt", "r") as f:
      line = f.readline().rstrip()
      while line:
          if (line[0:2] != "# "):
              print ("Unexpected input: " + line)
              break;
          # New Psalm
          countPsalms += 1
          countLines += 2
          title = line[2:]
          # Check for Part I/Part II
          line = f.readline().rstrip()
          countLines += 1
          if (title != "119" and line[0:3] == "## "):
              title = title + line[3:].replace (" ", "")
          # Open new file for writing
          with open (targetdir + "/" + title, "w") as t:
              while (len(line)>0):
                  if (line[0:3] == "## "):
                      if (title == "119" and line != "## Aleph"):
                          t.write("\n")
                      t.write(line[3:] + "\n")
                  elif (line[0:4] == "### "):
                      t.write(line[4:] + "\n")
                  else:
                      t.write(line + "\n")
                  line = f.readline().rstrip()
                  countLines += 1
          line = f.readline().rstrip()
  print ("Wrote " + str(countLines) + " lines in " + str(countPsalms) + " files.")
#+END_SRC

#+RESULTS:
: Wrote 6328 lines in 157files.

** Produce Psalms in =readings/pss/plain=
Format:
  - Blank line between Psalms/parts
  - # Psalm number (filename)
  - ## Part of Psalm or letter for Ps 119 (bold)
  - ### Latin title (italic)
  - Add "Part" to filename for those that contain the keyword
  - Psalm119: add a \n for each new letter heading

#+BEGIN_SRC python :python python3 :results output
  import os
  targetdir = "readings/pss/plain/"
  os.makedirs(targetdir, exist_ok=True)

  countLines = 0
  countPsalms = 0
  previousLine = ""
  with open("psalter.txt", "r") as f:
      line = f.readline().rstrip()
      while line:
          if (line[0:2] != "# "):
              print ("Unexpected input: " + line)
              break;
          # New Psalm
          countPsalms += 1
          countLines += 2
          title = line[2:]
          # Check for Part I/Part II
          line = f.readline().rstrip()
          countLines += 1
          if (title != "119" and line[0:3] == "## "):
              title = title + line[3:].replace (" ", "")
          # Open new file for writing
          with open (targetdir + "/" + title, "w") as t:
              while (len(line)>0):
                  if (line[0:3] == "## "):
                      if (title == "119" and line != "## Aleph"):
                          t.write("\n")
                      t.write("**" + line[3:] + "**" + "\n")
                  elif (line[0:4] == "### "):
                      t.write("_" + line[4:] + "_" + "\n")
                  else:
                      t.write(line + "\n")
                  line = f.readline().rstrip()
                  countLines += 1
          line = f.readline().rstrip()
  print ("Wrote " + str(countLines) + " lines in " + str(countPsalms) + " files.")
#+END_SRC

#+RESULTS:
: Wrote 6328 lines in 157files.
** Produce Psalms in =readings/pss/responsively=
Format:
  - Blank line between Psalms/parts
  - # Psalm number (filename)
  - ## Part of Psalm or letter for Ps 119 (bold)
  - ### Latin title (italic)
  - Add "Part" to filename for those that contain the keyword
  - Psalm119: add a \n for each new letter heading

#+BEGIN_SRC python :python python3 :results output
  import os
  targetdir = "readings/pss/responsively/"
  os.makedirs(targetdir, exist_ok=True)

  countLines = 1
  countPsalms = 0
  with open("psalter.txt", "r") as f:
      line = f.readline().rstrip()
      while line:
          if (line[0:2] != "# "):
              print ("Unexpected input: " + line)
              break;
          countPsalms += 1
          title = line[2:]

          # Check for Part I/Part II
          line = f.readline().rstrip()
          countLines += 1
          if (title != "119" and line[0:3] == "## "):
              title = title + line[3:].replace (" ", "")

          # Open new file for writing
          with open (targetdir + "/" + title, "w") as t:
              newPsalm = True
              responseOpen = False
              while (len(line)>0):
                  if not newPsalm:
                      t.write ("\n")
                  if (line[0:3] == "## "): # Part or Letter
                      if (title == "119"):
                          if (newPsalm):
                            t.write("_" + line[3:] + "_\n")
                          else:
                              t.write ("\n_" + line[3:] + "_")
                      else:
                          t.write("_" + line[3:] + "_\n")
                      line = f.readline().rstrip()
                  elif (line[0:4] == "### "): # latin title
                      if (title == "119"):
                          t.write("_" + line[4:] + "_\n")
                      else:
                          t.write("_" + line[4:] + "_\n\n")
                      line = f.readline().rstrip()
                  else:
                      if (line[0].isdigit()):
                          responseOpen = not newPsalm and not responseOpen
                          newPsalm = False
                          if responseOpen:
                              t.write ("> **" + line)
                          else:
                              t.write ("> " + line)
                      else:
                          t.write (line)
                      line = f.readline().rstrip()
                      countLines += 1
                      if (responseOpen and (len(line) == 0 or line[0].isdigit())):
                          t.write("**\n") # two \n's on purpose
              line = f.readline().rstrip() # Drew a blank: try for another line
  print ("Wrote " + str(countLines) + " lines in " + str(countPsalms) + " files.")
#+END_SRC

#+RESULTS:
: Wrote 5801 lines in 157 files.
** Better Psalm parser
Load each Psalm into memory at once, then format & output as needed
Format of input file:
  - Blank line between Psalms
  - # Psalm number (filename)
  - ## Part of Psalm or letter for Ps 119 (bold)
  - ### Latin title (italic)
  - When Parts/titles occur mid-Psalm, give an extra \n above it

#+BEGIN_SRC python :python python3 :results output
  import os
  targetdir_plaintext = "readings/pss/plaintext/"
  targetdir_markdown  = "readings/pss/markdown/"
  targetdir_responsively = "readings/pss/responsively/"
  os.makedirs(targetdir_plaintext, exist_ok=True)
  os.makedirs(targetdir_markdown, exist_ok=True)
  os.makedirs(targetdir_responsively, exist_ok=True)

  countPsalms = 0
  countLines = 0
  countFiles = 0
  with open("psalter.txt", "r") as f:
      line = f.readline().rstrip()
      countLines += 1
      while len(line) > 1:
          if (line[0:2] != "# "):
              print ("Unexpected input: " + line)
              break;
          countPsalms += 1
          title = line[2:]

          # Read in entire Psalm
          psalm = []
          line = f.readline()
          countLines += 1
          while len(line) > 1:
              psalm.append(line.rstrip())
              line = f.readline()
              countLines += 1

          # Output plaintext Psalm
          atTheBeginning = 2
          with open (targetdir_plaintext + "/" + title, "w") as t:
              countFiles += 1
              for l in psalm:
                  if (l[0:3] == "## "):
                      if (atTheBeginning <= 0 and l[0] == "#"):
                          t.write("\n")
                      t.write(l[3:] + "\n")
                  elif (l[0:4] == "### "):
                      t.write(l[4:] + "\n")
                  else:
                      t.write(l + "\n")
                  atTheBeginning -= 1

          # Output markdown Psalm
          atTheBeginning = 2
          with open (targetdir_markdown + "/" + title, "w") as t:
              countFiles += 1
              for l in psalm:
                  if (l[0:3] == "## "):
                      if (atTheBeginning <= 0 and l[0] == "#"):
                          t.write("\n")
                      t.write("**" + l[3:] + "**\n")
                  elif (l[0:4] == "### "):
                      t.write("_" + l[4:] + "_\n\n")
                  else:
                      t.write("> " + l + "\n")
                  atTheBeginning -= 1

          # Output responsive Psalm
          foundAVerse = False
          isEven = False
          with open (targetdir_responsively + "/" + title, "w") as t:
              countFiles += 1
              for l in psalm:
                  if (foundAVerse):
                      # If not the beginnig of the Psalm, finish off the last line
                      if (isEven and (l[0].isdigit() or l[0] == "#")):
                          t.write("**\n") # extra line between pairs
                      t.write("\n")

                  # Process the line
                  if (l[0:3] == "## "):
                      t.write("**" + l[3:] + "**\n")
                      isEven = False
                      foundAVerse = False
                  elif (l[0:4] == "### "):
                      t.write("_" + l[4:] + "_\n\n")
                      isEven = False
                      foundAVerse = False
                  else:
                      if (l[0].isdigit()):
                          t.write("> ")
                          if (foundAVerse):
                              isEven = not isEven
                          if (isEven):
                              t.write("**")
                          foundAVerse = True
                      t.write(l)
              # If not the beginnig of the Psalm, finish off the last line
              if (isEven):
                  t.write("**")
              t.write("\n")
          line = f.readline().rstrip()
          countLines += 1
  print ("Wrote " + str(countLines) + " lines in " + str(countFiles) + " files for " + str(countPsalms) + " Psalms.")
#+END_SRC

#+RESULTS:
: Wrote 6060 lines in 450 files for 150 Psalms.
